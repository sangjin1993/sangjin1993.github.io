<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹폰트 추가 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- 일본어 폰트 추가-->
    <link href="https://fonts.googleapis.com/css?family=Sawarabi+Mincho" rel="stylesheet">

    <!-- syntax.css추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- google search console-->
    <meta name="google-site-verification" content="1xqyQf76FFqB-txVJiGtlXwWpmJ2rO7n0GKfSRhd9Nw" />

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="IT技術の勉強を記録ためのblogです。" />
    <link rel="shortcut icon" href="https://sangjin1993.github.io/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="https://sangjin1993.github.io/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="記憶より記録" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="IT技術の勉強を記録ためのblogです。" />
    <meta property="og:url" content="https://sangjin1993.github.io/search" />
    <meta property="og:image" content="https://sangjin1993.github.io/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="IT技術の勉強を記録ためのblogです。" />
    <meta name="twitter:url" content="https://sangjin1993.github.io/" />
    <meta name="twitter:image" content="https://sangjin1993.github.io/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="記憶より記録" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "記憶より記録",
        "logo": "https://sangjin1993.github.io/"
    },
    "url": "https://sangjin1993.github.io/search",
    "image": {
        "@type": "ImageObject",
        "url": "https://sangjin1993.github.io/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://sangjin1993.github.io/search"
    },
    "description": "IT技術の勉強を記録ためのblogです。"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://sangjin1993.github.io/">記憶より記録</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-java" role="menuitem"><a href="/tag/java/">Java</a></li>
    <li class="nav-spring" role="menuitem"><a href="/tag/spring/">Spring</a></li>
    <li class="nav-japanese" role="menuitem"><a href="/tag/japanese/">Japanese</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag Posts</a>
    </li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "java-functionalinterface-lambda": {
        "title": "Java8 (1) 함수형 인터페이스와 람다표현식",
            "author": "sangjin",
            "category": "",
            "content": "Java8에서 추가된 기능들을 정리하는 포스트입니다.함수형 인터페이스와 람다 표현식이 포스트에서는 Java8에서 추가된 함수형 인터페이스와 람다에 대해서 포스트하겠습니다.함수형 인터페이스함수형 인터페이스란 추상 메소드가 하나인 인터페이스(SAM-Single Abstract Method)를 말합니다.함수형 인터페이스를 정의 할 때는 @FunctionalInterface 어노테이션을 사용할 수 있습니다.이 어노테이션을 사용시 문법에 위반되면 에러가 발생 됩니다.@FunctionalInterfacepublic interface FunctionalInterfaceExam {\t// 인터페이스에서 abstract를 생략 할수 있음 밑에있는것과 같은 것//\tabstract void doIt();\tvoid doIt();\t// 두 개가 있다 함수형인터페이스가 아님//\tvoid doItAgain();\t// java8 부터 인터페이스 안에 static 메소드를 정의 할 수 있음\tstatic void printName() {\t\tSystem.out.println(\"SangJin\");\t}\t// java8 부터 default 메소드도 정의 할 수 있음\tdefault void printAge() {\t\tSystem.out.println(\"28\");\t}\t// 함수형 인터페이스는 다른 메소드가 있어도 되지만 추상메소드는 오직 하나일 때만}람다 표현식(Lambda Expressions)람다 함수는 익명 함수(Anonymous functions)를 지칭하는 용어입니다.익명함수란함수의 이름이 없는 함수입니다. 익명함수들의 공통으로 일급객체(First Class citizen)라는 특징을 가지고 있습니다.일급겍체란 일반적으로 다른 객체들에 적용 가능한 연산을 모두 지원하는 객체를 가르킵니다. 함수를 값으로 사용할 수도 있드며 파라미터로 전달 및 변수에 대입하는 연산이 가능합니다.public class FunctionalInterfaceRun {\tpublic static void main(String[] args) {\t\t// Java8 이전에는 익명 내부 클래스 anonymous inner class\t\tFunctionalInterfaceExam runSomething1 = new FunctionalInterfaceExam() {\t\t\t@Override\t\t\tpublic void doIt() {\t\t\t\tSystem.out.println(\"Hello anonymous inner class\");\t\t\t}\t\t};\t\t// 실행\t\trunSomething1.doIt();\t\t// 위의 코드를 람다로 표현하면\t\tFunctionalInterfaceExam runSomething2 = () -&gt; System.out.println(\"Hello Lambda\");\t\t// 실행\t\trunSomething2.doIt();\t\t// 실행할 코드가 두 줄 이상일 때\t\tFunctionalInterfaceExam runSomething3 = () -&gt; {\t\t\tSystem.out.println(\"Hello\");\t\t\tSystem.out.println(\"Lambda\");\t\t};\t\t// 실행\t\trunSomething3.doIt();\t\t/*\t\t *  람다 표현식을 쓰면 어떤 함수를 정의한거 처럼 보이지만\t\t *  자바에서는 특수한 형태의 오브젝트임 \t\t *  함수형 인터페이스를 인라인으로 구현한 오브젝트로 볼 수있음\t\t *  이러한 형태를 함수처럼 보이지만 사실상 자바는 객체지향 언어라\t\t *  이것을 변수에 할당하고 이것을 메소드 파라미터를 전달하고 리턴타입으로 리턴할 수 있음\t\t *  이 말은 자바에서 함수를 First class object로 사용할 수 있다는 말임 \t\t */\t}}Java에서 함수형 프로그래밍  함수를 First Class Object로 사용할 수 있다.  순수 함수(Pure function)          사이드 이펙트가 없다. (함수 밖에서 있는 값을 변경하지 않는다.)      상태가 없다. (함수 밖에 값을 사용하지 않는다.)        고차 함수(Higher-Order-Function)          함수가 함수를 매개변수로 받을 수 있고 함수를 리턴할 수도 있다.        불변성수학적인 함수에서 가장 중요한 것은 입력받은 값이 동일한 경우 결과가 같아야 된다.순수함수// 어떤 값을 받고 리턴하는 메서드를 함수형 인터페이스@FunctionalInterfacepublic interface PureFunction {    int doIt(int number);}public class PureFunctionRun {    public static void main(String[] args) {                PureFunction runPureFunction = (number) -&gt; {            return number + 10;        }        // 동일한 값을 입력받으면 같은값(11)이 나와야한다.        System.out.println(runPureFunction.doIt(1));        System.out.println(runPureFunction.doIt(1));        System.out.println(runPureFunction.doIt(1));        // 12가 나와야 한다.        System.out.println(runPureFunction.doIt(2));        System.out.println(runPureFunction.doIt(2));        System.out.println(runPureFunction.doIt(2));    }}동일한 값이 안나오는 이유는 함수 안에서 밖에 있는 값을 참조해서 쓰는 경우public class PureFunctionRun {\tpublic static void main(String[] args) {\t\t// 함수의 밖 있는 값\t\tint baseNumber = 10;\t\t// 이런 경우는 상태값을 가지고 있다 어떤 값에 의존한다라고 해서 퓨어한 함수가 아님\t\tPureFunction runPureFunction1 = new PureFunction() {\t\t\t// 여기도 함수의 밖에 있는 값\t\t\tint baseNumber = 10;\t\t\t@Override\t\t\tpublic int doIt(int number) {\t\t\t\treturn number + baseNumber;\t\t\t}\t\t};\t\t// 또다른 케이스는 외부에 있는 값을 변경할려는 경우\t\t// 여기에 선언된 변수를 사용하면 문법적으로 안됌//\t\tint baseNumber1 = 10;\t\tPureFunction runPureFunction2 = new PureFunction() {\t\t\t// 이 경우는 문법적으로 가능\t\t\t// 가능하지만 퓨어한 함수가 아님\t\t\tint baseNumber1 = 10;\t\t\t@Override\t\t\tpublic int doIt(int number) {\t\t\t\tbaseNumber1++;\t\t\t\treturn number + baseNumber1;\t\t\t}\t\t};\t\tfinal int baseNumber2 = 10;\t\tPureFunction runPureFunction3 = new PureFunction() {\t\t\t@Override\t\t\tpublic int doIt(int number) {\t\t\t\treturn number + baseNumber2;\t\t\t}\t\t};\t\t// 밖에서 변경할려고 하면 오류 -&gt; 이유는 baseNumber2를 파이널이라고 가정하고 쓰는 것!!//\t\tbaseNumber2++;\t}}",
        "url": "/java-functionalInterface_lambda"
    }
    ,
    
    "japanese-1": {
        "title": "日本語能力試験N1文法 (1)",
            "author": "sangjin",
            "category": "",
            "content": "일본어능력시험N1를 합격하기 위해서 정리한 글입니다.자신을 위해서 정리한 내용이므로 의역이나 틀린 것이 있을 수 있습니다.1課　時間関係1. 〜が早いか⇒　するとすぐ続いて次のことが起こる。~하면 바로 계속해서 다음 것이 일어난다.동사의 사전형 / た형 + が早いか순간적인 것을 표현하는 동사를 사용. 이후에는, 화자가 조금 의외감(?)을 같고 사실을 표현하는 문장이 나옴. 화자의 회망, 의향을 표현하는 문장이나 주장은 안 나옴.2. 〜や•〜や否や⇒　〜とほとんど同時に次のことが起こる。~와 함깨 동시에 다음 것이 일어남.동사의 사전형 + 〜や•〜や否や순간적인 것을 표현하는 동사를 사용. 이후에는, 사실을 표현하는 문장이 나옴. 화자의 희망, 의향을 표현하는 문장이나 주장은 안 나옴.3.　〜なり⇒　〜という動作にすぐ連続して次のことをする。~라고하는 동작에 바로 연속해서 다음 것을 함.동사 사전형 + なり이후에는, 조금 의외감이 있고 의식적인 동작을 표현하는 문장이 옴. 주어는 보통 3인칭으로, 전후의 주어는 같다.4.　〜そばから⇒　〜をしても、すぐにそれに対抗するような動きがあり、それを何度も繰り返す。~을 해도, 바로 그것에 대항하는 움직임이 있고, 그것을 몇 번이고 반복함.동사 사전형 / た형 + そばから좋지 않은 것에 사용하는 것이 많음.5.　〜てからというもの(は)⇒　〜してからある変化が起こり、その後ずっと同じ状態が続いている。~해서 어떤 변화가 일어나, 그후 계속 같은 상태가 계속되고 있음.동사 て형 + からというもの별로 가까운 과거의 기간에는 사용하지 않음. 이후에는, 변화 후의 상태가 계속해서 있는 것을 표현하는 문장이 옮.6.　〜にあって⇒　〜のような特別な状況だからこそあることが起こる•〜のような特別な状況でもあることが起こる。~와 같은 특별한 상황이기 때문에 어떤 일이 일어남, ~와 같은 특별한 상황이라도 어떤 일이 일어남.명사 + にあって상황, 시기, 장소 등을 표현하는 명사를 사용. 이후에는 이런 상황이 없었으면 일어나지 않았을 것을 말하는 문장 또는 상황을 반하는 것을 말하는 문장이 옮. 이 경우 「〜にあっても」라는 형식이 있음.",
        "url": "/japanese-1"
    }
    ,
    
    "spring-2": {
        "title": "Object와 의존관계(2)",
            "author": "sangjin",
            "category": "",
            "content": "Object와 의존관계(2)저번 포스트에서는 인터페이스를 도입해도 구체적인 클래스를 요구하는 하는 것은 달라지지 않았습니다.이제 Dependency injection을 도입해서 해결해 보겠습니다.백기선강사님유튜브  Dependency injection 적용  Factory 도입  스프링 @IoC도입1. Dependency injection 적용Dependency injection의 개념은 자신이 필요로하는 객체 즉, UserDao가 필요하는 의존성을 SimpleConnectionMaker를 자신이 생성하는 것(new)이 아니라 외부에서 주입 받는 것입니다.public class UserDao {    ConnectionMaker connectionMaker;    // 기본 생성자    public UserDao(){    }    // UserDao는 의존성을 받을 수 있는 장치를 마련해야합니다.    // 생성자로 자신이 필요로하는 의존성을 주입할 수 있습니다.    public UserDao(Connectionmaker connectionMaker) {        this.connectionMaker = connectionMaker;    }    // 또한 setter를 이용해서 주입받을 수 있습니다.    public void setConncetionMaker(ConnectionMaker conncetionMaker) {        this.connectionMaker = connectionMaker;    }    ...}이때 UserDao의 의존성을 누가 주입할까요?바로 UserDao를 사용하는 외부의 어떤 설정파일로 주입해줄 수 있습니다.간단하게 UserDaoTest클레스에서 주입을 받아 보겠습니다.public class UserDaoTest {    public static void main(String[] args) throws ClassNotFoundException, SQLException {        // ConnectionMaker타입의 simpleConnectionMaker를 만듦        ConnectionMaker connectionMaker = new simpleConnectionMaker();        // UserDao의 생성자에 connectionMaker 주입        UserDao userDao = new UserDao(connectionMaker);        User user = new User();        user.setId(\"jin\");        user.setName(\"진\");        user.setPassword(\"1993\");        userDao.add(user);    }}Dependency injection을 적용해봤습니다.Dependency injection은 스프링에만 국한 되어 있는 기술이 아니라 객체지향프로그래밍을 사용하면 객체간의 의존관계가 있을 때 사용할 수 있는 기술입니다.이제 위의 테스트 코드를 개선해보겠습니다.이 테스트 코드에는 책임이 두 가지 있습니다.첫 번째는 ConnectionMaker 객체를 생성해서 UserDao에 주입해 관계를 맺는 일입니다.두 번째는 주입받은 UserDao를 이용해서 기능을 테스트하는 것입니다.2. Factory 도입ConnectionMaker 객체 생성하는 기능을 Factory를 도입해서 개선하겠습니다.DaoFactory 클래스를 만듭니다.public class DaoFactory {    // DaoFactory에서 UserDao객체를 만들어줌    public UserDao userDao() {        ConnectionMaker connectionMaker = new simpleConnectionMaker();        return new UserDao(connectionMaker);    }}이제 테스트 코드에서는 DaoFacory에서 UserDao를 가져오면 됩니다.public class UserDaoTest {    public static void main(String[] args) throws ClassNotFoundException, SQLException {                UserDao userDao = new DaoFactory().userDao();        User user = new User();        user.setId(\"jin\");        user.setName(\"진\");        user.setPassword(\"1993\");        userDao.add(user);    }}DaoFactory를 이용해서 테스트 코드의 ConnectionMaker객체 생성의 책임이 없어졌습니다. 온전히 test를 위한 책임만 있는 클래스로 개선되었습니다.3. 스프링 @IoC도입이제 스프링의 IoC기능을 이용하겠습니다.@Configuraion을 사용해서 DaoFactory를 스프링의 설정파일로 사용할 수 있습니다.Bean을 만들어 주는 메서드에는 @Bean어노테이션을 붙여줍니다.@Configurationpublic class DaoFactory {        @Bean    public UserDao userDao() {        ConnectionMaker connectionMaker = new simpleConnectionMaker();        return new UserDao(connectionMaker);    }}이제 태스트코드에서는 ApplicationContext를 만듭니다. 자바빈 설정파일을 사용할 수 있는 AnnotationConfigApplicationContext()를 만들고 생성자로 빈설정 파일이 될 수 있는 class를 지정해줍니다.이제 UserDao를 ApplicationContext에서 가져오면 됩니다.public class UserDaoTest {    public static void main(String[] args) throws ClassNotFoundException, SQLException {        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(DaoFactory.class);        // getBean(\"메서드이름\", 타입)        UserDao userDao = applicationContext.getBean(\"userDoa\", UserDao.class);        User user = new User();        user.setId(\"jin\");        user.setName(\"진\");        user.setPassword(\"1993\");        userDao.add(user);    }}DaoFactory를 Configuration에노테이션을 이용해서 빈설정 파일료 사용할 수 있게 만들었습니다.그 다음 테스트 코드에서 AnnotionConfigApplicationContext를 사용해서 자바 설정 파일 즉 @Configuration이 붙은 DaoFactory의 @Bean이 있는 메소드를 사용했습니다.여기서 DaoFactory를 사용하면 되지 왜 AnnotionConfigApplicationContext를 왜 사용할까요?DaoFactory에서 userDao의 매서드를 호출 할 때 마다 new로 객체를 만들지만 빈설정 파일을 사용하는 AnnotionConfigApplicationContext는 getBean()을 사용할 때 같은 객체를 받을 수 있습니다. 즉, 싱글톤 객체를 반환합니다.AnnotionConfigApplicationContext는 Bean의 스코프 관리를 해주고 생성및 소멸(라이플사이클)제공 해줍니다. 또한 다양한 기능을 사용할 수 있습니다. 예로 자바파일을 설정파일로 사용할 수 있지만 xml, properties파일로도 설정할 수 있습니다.이처럼 IoC컨테이너는 다양한 기능을 제공해줍니다.",
        "url": "/spring-2"
    }
    ,
    
    "spring-1": {
        "title": "Object와 의존관계(1)",
            "author": "sangjin",
            "category": "",
            "content": "Object와 의존관계(1)스프링 Dependency injection에 대해서 공부하던 중 백기선 강사님의 유튜브에 깔끔하게 설명한 강의가 있어 참고하여 정리하였습니다.백기선강사님유튜브DAO(Data-Access-Object)를 가지고 설명DAO는 데이터접근에 관련한 클레스로 중복이 많이 발생하는 대표적인 클레스입니다.이 클레스를 가지고 단계별로 스프링의　dependency injection과 Ioc를 설명하겠습니다.  중복제거  Connection생성 방식 확장(상속)  Connection생성 방식 확장(위임)  인터페이스 도입간단한 id와 name, password를 가지는 User도메인 클래스입니다.public class User {    String id;    String name;    String password;    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getName() {        return name;    }    pubic void SetName(String name) {        this.name = name;    }    public String getPassword() {        return password:    }    public void setPassword(String password) {        this.password = password;    }} Connection객체를 만들어 add와 get을 수행하는 UserDao클래스입니다.public class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }}1. UserDao의 중복코드를 제거(Connection부분)Class.forName(\"org.postgresql.Driver\");Connection connection = DriverManager        .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");    위 코드는 add와 get메서드에서 중복된 코드입니다.이 코드를 makeConnection()메서드로 만들어서 중복제거를 합니다.public class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    private Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}2. Connection생성 방식 확장(상속) - 탬플릿 메서드 패턴makeConnection()메서드를 만들어서 중복제거를 해결했습니다.중복을 제거했지만 커넥션 정보를 UserDao와 별개로 add, get코드의 변경없이 makeConnection()의 코드만 외부에서 바꿀 수 있도록 확장가능한 형태로 할려면 어떻게 해야할까요?상속을 이용해서 구현해보겠습니다.상속을 위해서는 UserDao클레스를 추상클래스로 만듭니다public abstract class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    // 이 메서드 자체를 추상메서드로 만듬(탬플릿메서드)    public abstract Connection makeConnection() throws ClassNotFoundException, SQLException;}UserDao를 상속하는 하위클래스NUserDao를 만들어 커넥션 객체(makeConnection)를 만드는 기능을 구현public class NuserDao extends UserDao {    @Override    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}UserDao를 확장한 NUserDao관계는 상속을 통해서 매우 밀접한 관계가 되었습니다.UserDao의 어떤 내용이 바뀌면 NUserDao를 비롯해서 상속받은 모든 하위클래스들이 전부다 영향을 받게됩니다.또한 NUserDao는 UserDao를 상속받아서 다른 클래스를 상속받을 수 없습니다.3. Connection생성 방식 확장(위임)상속을 통한 Connection생성 방식은 컴파일 시점에서 관계가 굳어져 버려 조금 더 유연한 방법인 위임을 통해서 구현해보겠습니다.SimpleConnectionMaker클래스를 만들어 NUserDao에 있던 코드를 옮깁니다.public class SimpleConnectionMaker {    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}NUserDao를 지우고 UserDao를 다시 일반 클래스로 바꿉니다.public class UserDao {    // SimpleConnectionMaker객체를 만듬    SimpleConnectionMaker connectionMaker = new SimpleConnectionMaker();    public void add(User user) throws ClassNotFoundException, SQLException {        // connectionMaker에 위임을 함        Connection connection = connectionMaker.makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = connectionMaker.makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    }UserDao와 SimpleConnectionMaker의 관계를 살펴보면 상속에서 위임으로 바뀌였지만 아직도 컴파일시점에 타이트한 관계입니다. connectionMaker객체를 다른 객체로 바꿀려면 코드를 수정해야하는 상황이 나옵니다. 그러면 SimpleConnectionMaker의 부문이 계속해서 바뀌여야 합니다. 또한 makeConnection()이라는 메서드도 보장받을 수 없습니다.이렇때 생각할 수 있는 방법은 인터페이스를 도입하는 것입니다.4. 인터페이스 도입ConnectionMaker라는 인터페이스를 만듭니다.public interface ConnectionMaker {    // makeConnection이라는 규약을 만듭니다.    public Connection makeConnection() throws ClassNotFoundException, SQLException;}SimpleConnectionMaker는 ConnectionMaker를 구현합니다.public class SimpleConnectionMaker implements ConnectionMaker {    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}UserDao에서는 ConnectionMaker의 인터페이스를 사용하게 합니다.public class UserDao {    // ConncetionMaker인터페이스를 사용    ConnectionMaker connectionMaker = new SimpleConnectionMaker();    public void add(User user) throws ClassNotFoundException, SQLException {        // connectionMaker에 위임을 함        Connection connection = connectionMaker.makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = connectionMaker.makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    }인터페이스를 사용해서 관계가 느슨해졌을까요? 아닙니다. 여전히 UserDao클래스에서 구체적인 클래스(SimpleConnectionMaker)를 쓰고있습니다. 단지 인터페이스를 사용해서 makeConnection()메서드를 보장 받을 수 있게되었습니다. ConnectionMaker이 다른 구현체를 사용해도 makeConnection()메서드는 보장 받을 수 있습니다.ConnectionMaker connectionMaker = new SimpleConnectionMaker();은 어떻게 해야할까요?다음 포스트에서 설명하겠습니다.",
        "url": "/spring-1"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://sangjin1993.github.io/">記憶より記録</a> &copy; 2021</section>
                <!--<section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section> -->
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search 記憶より記録</h1>
                <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
            </div>
        </div>
    


    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
