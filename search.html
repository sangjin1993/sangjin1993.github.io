<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹폰트 추가 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- 일본어 폰트 추가-->
    

    <!-- syntax.css추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- google search console-->
    <meta name="google-site-verification" content="1xqyQf76FFqB-txVJiGtlXwWpmJ2rO7n0GKfSRhd9Nw" />

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="IT技術の勉強を記録ためのblogです。" />
    <link rel="shortcut icon" href="http://localhost:4000/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="http://localhost:4000/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="記憶より記録" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="IT技術の勉強を記録ためのblogです。" />
    <meta property="og:url" content="http://localhost:4000/search" />
    <meta property="og:image" content="http://localhost:4000/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="IT技術の勉強を記録ためのblogです。" />
    <meta name="twitter:url" content="http://localhost:4000/" />
    <meta name="twitter:image" content="http://localhost:4000/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="記憶より記録" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "記憶より記録",
        "logo": "http://localhost:4000/"
    },
    "url": "http://localhost:4000/search",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4000/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4000/search"
    },
    "description": "IT技術の勉強を記録ためのblogです。"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4000/">記憶より記録</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-java" role="menuitem"><a href="/tag/java/">Java</a></li>
    <li class="nav-spring" role="menuitem"><a href="/tag/spring/">Spring</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "spring-2": {
        "title": "Object와 의존관계(2)",
            "author": "sangjin",
            "category": "",
            "content": "Object와 의존관계(2)저번 포스트에서는 인터페이스를 도입해도 구체적인 클래스를 요구하는 하는 것은 달라지지 않았습니다.이제 Dependency injection을 도입해서 해결해 보겠습니다.백기선강사님유튜브  Dependency injection 적용  Factory 도입  스프링 @IoC도입1. Dependency injection 적용Dependency injection의 개념은 자신이 필요로하는 객체 즉, UserDao가 필요하는 의존성을 SimpleConnectionMaker를 자신이 생성하는 것(new)이 아니라 외부에서 주입 받는 것입니다.public class UserDao {    ConnectionMaker connectionMaker;    // 기본 생성자    public UserDao(){    }    // UserDao는 의존성을 받을 수 있는 장치를 마련해야합니다.    // 생성자로 자신이 필요로하는 의존성을 주입할 수 있습니다.    public UserDao(Connectionmaker connectionMaker) {        this.connectionMaker = connectionMaker;    }    // 또한 setter를 이용해서 주입받을 수 있습니다.    public void setConncetionMaker(ConnectionMaker conncetionMaker) {        this.connectionMaker = connectionMaker;    }    ...}이때 UserDao의 의존성을 누가 주입할까요?바로 UserDao를 사용하는 외부의 어떤 설정파일로 주입해줄 수 있습니다.간단하게 UserDaoTest클레스에서 주입을 받아 보겠습니다.public class UserDaoTest {    public static void main(String[] args) throws ClassNotFoundException, SQLException {        // ConnectionMaker타입의 simpleConnectionMaker를 만듦        ConnectionMaker connectionMaker = new simpleConnectionMaker();        // UserDao의 생성자에 connectionMaker 주입        UserDao userDao = new UserDao(connectionMaker);        User user = new User();        user.setId(\"jin\");        user.setName(\"진\");        user.setPassword(\"1993\");        userDao.add(user);    }}Dependency injection을 적용해봤습니다.Dependency injection은 스프링에만 국한 되어 있는 기술이 아니라 객체지향프로그래밍을 사용하면 객체간의 의존관계가 있을 때 사용할 수 있는 기술입니다.이제 위의 테스트 코드를 개선해보겠습니다.이 테스트 코드에는 책임이 두 가지 있습니다.첫 번째는 ConnectionMaker 객체를 생성해서 UserDao에 주입해 관계를 맺는 일입니다.두 번째는 주입받은 UserDao를 이용해서 기능을 테스트하는 것입니다.2. Factory 도입ConnectionMaker 객체 생성하는 기능을 Factory를 도입해서 개선하겠습니다.DaoFactory 클래스를 만듭니다.public class DaoFactory {    // DaoFactory에서 UserDao객체를 만들어줌    public UserDao userDao() {        ConnectionMaker connectionMaker = new simpleConnectionMaker();        return new UserDao(connectionMaker);    }}이제 테스트 코드에서는 DaoFacory에서 UserDao를 가져오면 됩니다.public class UserDaoTest {    public static void main(String[] args) throws ClassNotFoundException, SQLException {                UserDao userDao = new DaoFactory().userDao();        User user = new User();        user.setId(\"jin\");        user.setName(\"진\");        user.setPassword(\"1993\");        userDao.add(user);    }}DaoFactory를 이용해서 테스트 코드의 ConnectionMaker객체 생성의 책임이 없어졌습니다. 온전히 test를 위한 책임만 있는 클래스로 개선되었습니다.3. 스프링 @IoC도입",
        "url": "/spring-2"
    }
    ,
    
    "spring-1": {
        "title": "Object와 의존관계(1)",
            "author": "sangjin",
            "category": "",
            "content": "Object와 의존관계(1)스프링 Dependency injection에 대해서 공부하던 중 백기선 강사님의 유튜브에 깔끔하게 설명한 강의가 있어 참고하여 정리하였습니다.백기선강사님유튜브DAO(Data-Access-Object)를 가지고 설명DAO는 데이터접근에 관련한 클레스로 중복이 많이 발생하는 대표적인 클레스입니다.이 클레스를 가지고 단계별로 스프링의　dependency injection과 Ioc를 설명하겠습니다.  중복제거  Connection생성 방식 확장(상속)  Connection생성 방식 확장(위임)  인터페이스 도입간단한 id와 name, password를 가지는 User도메인 클래스입니다.public class User {    String id;    String name;    String password;    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getName() {        return name;    }    pubic void SetName(String name) {        this.name = name;    }    public String getPassword() {        return password:    }    public void setPassword(String password) {        this.password = password;    }} Connection객체를 만들어 add와 get을 수행하는 UserDao클래스입니다.public class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }}1. UserDao의 중복코드를 제거(Connection부분)Class.forName(\"org.postgresql.Driver\");Connection connection = DriverManager        .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");    위 코드는 add와 get메서드에서 중복된 코드입니다.이 코드를 makeConnection()메서드로 만들어서 중복제거를 합니다.public class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    private Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}2. Connection생성 방식 확장(상속) - 탬플릿 메서드 패턴makeConnection()메서드를 만들어서 중복제거를 해결했습니다.중복을 제거했지만 커넥션 정보를 UserDao와 별개로 add, get코드의 변경없이 makeConnection()의 코드만 외부에서 바꿀 수 있도록 확장가능한 형태로 할려면 어떻게 해야할까요?상속을 이용해서 구현해보겠습니다.상속을 위해서는 UserDao클레스를 추상클래스로 만듭니다public abstract class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    // 이 메서드 자체를 추상메서드로 만듬(탬플릿메서드)    public abstract Connection makeConnection() throws ClassNotFoundException, SQLException;}UserDao를 상속하는 하위클래스NUserDao를 만들어 커넥션 객체(makeConnection)를 만드는 기능을 구현public class NuserDao extends UserDao {    @Override    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}UserDao를 확장한 NUserDao관계는 상속을 통해서 매우 밀접한 관계가 되었습니다.UserDao의 어떤 내용이 바뀌면 NUserDao를 비롯해서 상속받은 모든 하위클래스들이 전부다 영향을 받게됩니다.또한 NUserDao는 UserDao를 상속받아서 다른 클래스를 상속받을 수 없습니다.3. Connection생성 방식 확장(위임)상속을 통한 Connection생성 방식은 컴파일 시점에서 관계가 굳어져 버려 조금 더 유연한 방법인 위임을 통해서 구현해보겠습니다.SimpleConnectionMaker클래스를 만들어 NUserDao에 있던 코드를 옮깁니다.public class SimpleConnectionMaker {    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}NUserDao를 지우고 UserDao를 다시 일반 클래스로 바꿉니다.public class UserDao {    // SimpleConnectionMaker객체를 만듬    SimpleConnectionMaker connectionMaker = new SimpleConnectionMaker();    public void add(User user) throws ClassNotFoundException, SQLException {        // connectionMaker에 위임을 함        Connection connection = connectionMaker.makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = connectionMaker.makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    }UserDao와 SimpleConnectionMaker의 관계를 살펴보면 상속에서 위임으로 바뀌였지만 아직도 컴파일시점에 타이트한 관계입니다. connectionMaker객체를 다른 객체로 바꿀려면 코드를 수정해야하는 상황이 나옵니다. 그러면 SimpleConnectionMaker의 부문이 계속해서 바뀌여야 합니다. 또한 makeConnection()이라는 메서드도 보장받을 수 없습니다.이렇때 생각할 수 있는 방법은 인터페이스를 도입하는 것입니다.4. 인터페이스 도입ConnectionMaker라는 인터페이스를 만듭니다.public interface ConnectionMaker {    // makeConnection이라는 규약을 만듭니다.    public Connection makeConnection() throws ClassNotFoundException, SQLException;}SimpleConnectionMaker는 ConnectionMaker를 구현합니다.public class SimpleConnectionMaker implements ConnectionMaker {    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}UserDao에서는 ConnectionMaker의 인터페이스를 사용하게 합니다.public class UserDao {    // ConncetionMaker인터페이스를 사용    ConnectionMaker connectionMaker = new SimpleConnectionMaker();    public void add(User user) throws ClassNotFoundException, SQLException {        // connectionMaker에 위임을 함        Connection connection = connectionMaker.makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = connectionMaker.makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    }인터페이스를 사용해서 관계가 느슨해졌을까요? 아닙니다. 여전히 UserDao클래스에서 구체적인 클래스(SimpleConnectionMaker)를 쓰고있습니다. 단지 인터페이스를 사용해서 makeConnection()메서드를 보장 받을 수 있게되었습니다. ConnectionMaker이 다른 구현체를 사용해도 makeConnection()메서드는 보장 받을 수 있습니다.ConnectionMaker connectionMaker = new SimpleConnectionMaker();은 어떻게 해야할까요?다음 포스트에서 설명하겠습니다.",
        "url": "/spring-1"
    }
    ,
    
    "java-basic": {
        "title": "java 강좌(1) - java 기본",
            "author": "sangjin",
            "category": "",
            "content": "java 강좌는 여러 절로 구성되어 있습니다.     Java 강좌(1) - Java 기본    Java 강좌(2) - Java 제어문이글은 java에 관한 포스트입니다.class main {    String name;    int age;}",
        "url": "/java-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://localhost:4000/">記憶より記録</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search 記憶より記録</h1>
                <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
            </div>
        </div>
    


    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
