<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Search Result</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- custom.css-->
    <link rel="stylesheet" type="text/css" href="/assets/built/custom.css" />

    <!-- font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- 웹폰트 추가 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/earlyaccess/nanumgothic.css">

    <!-- syntax.css추가 -->
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />

    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- google search console-->
    <meta name="google-site-verification" content="1xqyQf76FFqB-txVJiGtlXwWpmJ2rO7n0GKfSRhd9Nw" />

    <!--[if IE]>
        <style>
            p, ol, ul{
                width: 100%;
            }
            blockquote{
                width: 100%;
            }
        </style>
    <![endif]-->
    
    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="it" />
    <link rel="shortcut icon" href="http://localhost:4000/assets/built/images/favicon.jpg" type="image/png" />
    <link rel="canonical" href="http://localhost:4000/search" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="IT Technical Training" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Search Result" />
    <meta property="og:description" content="it" />
    <meta property="og:url" content="http://localhost:4000/search" />
    <meta property="og:image" content="http://localhost:4000/assets/built/images/blog-cover1.png" />
    <meta property="article:publisher" content="https://www.facebook.com/" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Search Result" />
    <meta name="twitter:description" content="it" />
    <meta name="twitter:url" content="http://localhost:4000/" />
    <meta name="twitter:image" content="http://localhost:4000/assets/built/images/blog-cover1.png" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="IT Technical Training" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
    <meta property="og:image:width" content="2000" />
    <meta property="og:image:height" content="666" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "IT Technical Training",
        "logo": "http://localhost:4000/"
    },
    "url": "http://localhost:4000/search",
    "image": {
        "@type": "ImageObject",
        "url": "http://localhost:4000/assets/built/images/blog-cover1.png",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://localhost:4000/search"
    },
    "description": "it"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Search Result" href="/feed.xml" />


</head>
<body class="page-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- < default -->
<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<!-- The big featured header, it uses blog cover image as a BG if available -->
<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="http://localhost:4000/">IT Technical Training</a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-about" role="menuitem"><a href="/about/">About</a></li>
    <li class="nav-java" role="menuitem"><a href="/tag/java/">Java</a></li>
    <li class="nav-spring" role="menuitem"><a href="/tag/spring/">Spring</a></li>
    <li class="nav-archive" role="menuitem">
        <a href="/archive.html">All Posts</a>
    </li>
    <li class="nav-archive" role="menuitem">
        <a href="/author_archive.html">Tag Posts</a>
    </li>
</ul>
        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
            <a class="subscribe-button" href="#subscribe">Search</a>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full  post page no-image">

            <header class="post-full-header">
                <h1 class="post-full-title">Search Result</h1>
            </header>

            

            <section class="post-full-content">
                <form action="/search" method="get" hidden="hidden">
    <label for="search-box"></label>
    <input type="text" id="search-box" name="query">
</form>

<ul class="mylist" id="search-results"></ul>

<script>
    window.store = {
    
    "spring": {
        "title": "Object와 의존관계",
            "author": "sangjin",
            "category": "",
            "content": "Object와 의존관계스프링 Dependency injection에 대해서 공부하던 중 백기선 강사님의 유튜브에 깔끔하게 설명한 강의가 있어 참고하여 정리하였습니다.백기선강사님유튜브DAO(Data-Access-Object)를 가지고 설명DAO는 데이터접근에 관련한 클레스로 중복이 많이 발생하는 대표적인 클레스입니다.이 클레스를 가지고 단계별로 스프링의　dependency injection과 Ioc를 설명하겠습니다.  중복제거  Connection생성 방식 확장(상속)  Connection생성 방식 확장(위임)  인터페이스 도입  Dependency injection 적용  Factory 도입  스프링 @IoC도입간단한 id와 name, password를 가지는 User도메인 클래스입니다.public class User {    String id;    String name;    String password;    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getName() {        return name;    }    pubic void SetName(String name) {        this.name = name;    }    public String getPassword() {        return password:    }    public void setPassword(String password) {        this.password = password;    }} Connection객체를 만들어 add와 get을 수행하는 UserDao클래스입니다.public class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }}1. UserDao의 중복코드를 제거(Connection부분)Class.forName(\"org.postgresql.Driver\");Connection connection = DriverManager        .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");    위 코드는 add와 get메서드에서 중복된 코드입니다.이 코드를 makeConnection()메서드로 만들어서 중복제거를 합니다.public class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    private Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}2. Connection생성 방식 확장(상속) - 탬플릿 메서드 패턴makeConnection()메서드를 만들어서 중복제거를 해결했습니다.중복을 제거했지만 커넥션 정보를 UserDao와 별개로 add, get코드의 변경없이 makeConnection()의 코드만 외부에서 바꿀 수 있도록 확장가능한 형태로 할려면 어떻게 해야할까요?상속을 이용해서 구현해보겠습니다.상속을 위해서는 UserDao클레스를 추상클래스로 만듭니다public abstract class UserDao {    public void add(User user) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    // 이 메서드 자체를 추상메서드로 만듬(탬플릿메서드)    public abstract Connection makeConnection() throws ClassNotFoundException, SQLException;}UserDao를 상속하는 하위클래스NUserDao를 만들어 커넥션 객체(makeConnection)를 만드는 기능을 구현public class NuserDao extends UserDao {    @Override    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}UserDao를 확장한 NUserDao관계는 상속을 통해서 매우 밀접한 관계가 되었습니다.UserDao의 어떤 내용이 바뀌면 NUserDao를 비롯해서 상속받은 모든 하위클래스들이 전부다 영향을 받게됩니다.또한 NUserDao는 UserDao를 상속받아서 다른 클래스를 상속받을 수 없습니다.3. Connection생성 방식 확장(위임)상속을 통한 Connection생성 방식은 컴파일 시점에서 관계가 굳어져 버려 조금 더 유연한 방법인 위임을 통해서 구현해보겠습니다.SimpleConnectionMaker클래스를 만들어 NUserDao에 있던 코드를 옮깁니다.public class SimpleConnectionMaker {    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}NUserDao를 지우고 UserDao를 다시 일반 클래스로 바꿉니다.public class UserDao {    // SimpleConnectionMaker객체를 만듬    SimpleConnectionMaker connectionMaker = new SimpleConnectionMaker();    public void add(User user) throws ClassNotFoundException, SQLException {        // connectionMaker에 위임을 함        Connection connection = connectionMaker.makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = connectionMaker.makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    }UserDao와 SimpleConnectionMaker의 관계를 살펴보면 상속에서 위임으로 바뀌였지만 아직도 컴파일시점에 타이트한 관계입니다. connectionMaker객체를 다른 객체로 바꿀려면 코드를 수정해야하는 상황이 나옵니다. 그러면 SimpleConnectionMaker의 부문이 계속해서 바뀌여야 합니다. 또한 makeConnection()이라는 메서드도 보장받을 수 없습니다.이렇때 생각할 수 있는 방법은 인터페이스를 도입하는 것입니다.4. 인터페이스 도입ConnectionMaker라는 인터페이스를 만듭니다.public interface ConnectionMaker {    // makeConnection이라는 규약을 만듭니다.    public Connection makeConnection() throws ClassNotFoundException, SQLException;}SimpleConnectionMaker는 ConnectionMaker를 구현합니다.public class SimpleConnectionMaker implements ConnectionMaker {    public Connection makeConnection() throws ClassNotFoundException, SQLException {        Class.forName(\"org.postgresql.Driver\");        Connection connection = DriverManager                .getConnection(\"jdbc:postgresql://localhost/spring30\", \"spring30\", \"spring30\");          return connection;    }}UserDao에서는 ConnectionMaker의 인터페이스를 사용하게 합니다.public class UserDao {    // ConncetionMaker인터페이스를 사용    ConnectionMaker connectionMaker = new SimpleConnectionMaker();    public void add(User user) throws ClassNotFoundException, SQLException {        // connectionMaker에 위임을 함        Connection connection = connectionMaker.makeConnection();        PreparedStatement statement = connection                .preparsStatement(\"insert into users(id, name, password) values (?, ?, ?)\");        statement.setString(1, user.getId());        statement.setString(2, user.getNmae());        statement.setString(3, user.getPassword());        statement.close();        connection.close();    }    public User get(String id) throws ClassNotFoundException, SQLException {        Connection connection = connectionMaker.makeConnection();        preparesdStatement statement = connection                .prepareStatement(\"select * from users where id = ?\");        statement.setString(1, id);        ResultSet resultSet = statement.executeQuery();        resultSet.next();        User user = new User();        user.setId(resultSet.getString(\"id\"));        user.setName(resultSet.getString(\"name\"));        user.setPassword(resultSet.getString(\"password\"));        resultSet.close();        statement.close();        connection.close();        return user;    }    }인터페이스를 사용해서 관계가 느슨해졌을까요? 아닙니다. 여전히 UserDao클래스에서 구체적인 클래스(SimpleConnectionMaker)를 쓰고있습니다. 단지 인터페이스를 사용해서 makeConnection()메서드를 보장 받을 수 있게되었습니다. ConnectionMaker이 다른 구현체를 사용해도 makeConnection()메서드는 보장 받을 수 있습니다.ConnectionMaker connectionMaker = new SimpleConnectionMaker();은 어떻게 해야할까요?",
        "url": "/spring"
    }
    ,
    
    "java-basic": {
        "title": "java 강좌(1) - java 기본",
            "author": "sangjin",
            "category": "",
            "content": "java 강좌는 여러 절로 구성되어 있습니다.     Java 강좌(1) - Java 기본    Java 강좌(2) - Java 제어문이글은 java에 관한 포스트입니다.class main {    String name;    int age;}",
        "url": "/java-basic"
    }
    
    
    };
</script>
<script src="assets/js/lunr.js"></script>
<script src="assets/js/search.js"></script>
            </section>

        </article>

    </div>
</main>

<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->
<script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>



        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="http://localhost:4000/">IT Technical Training</a> &copy; 2021</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    
        <div id="subscribe" class="subscribe-overlay">
            <a class="subscribe-overlay-close" href="#"></a>
            <div class="subscribe-overlay-content">
                
                <h1 class="subscribe-overlay-title">Search IT Technical Training</h1>
                <p class="subscribe-overlay-description">
                lunr.js를 이용한 posts 검색 </p>
                <span id="searchform" method="post" action="/subscribe/" class="">
    <input class="confirm" type="hidden" name="confirm"  />
    <input class="location" type="hidden" name="location"  />
    <input class="referrer" type="hidden" name="referrer"  />

    <div class="form-group">
        <input class="subscribe-email" onkeyup="myFunc()" 
               id="searchtext" type="text" name="searchtext"  
               placeholder="Search..." />
    </div>
    <script type="text/javascript">
        function myFunc() {
            if(event.keyCode == 13) {
                var url = encodeURIComponent($("#searchtext").val());
                location.href = "/search.html?query=" + url;
            }
        }
    </script>
</span>
            </div>
        </div>
    


    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-xxxxxxxx-x', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>
$(function() {
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
